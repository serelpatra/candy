<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ø¨Ø§Ø²ÛŒ Ú©Ù†Ø¯ÛŒ Ú©Ø±Ø§Ø´</title>

    <script src="https://telegram.org/js/telegram-web-app.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Vazirmatn', sans-serif;
            touch-action: manipulation; /* ØºÛŒØ±ÙØ¹Ø§Ù„ Ú©Ø±Ø¯Ù† Ø²ÙˆÙ… Ø¨Ø§ Ø¯Ùˆ Ø¨Ø§Ø± Ø¶Ø±Ø¨Ù‡ Ø¯Ø± Ù…ÙˆØ¨Ø§ÛŒÙ„ */
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 4px solid #8B5CF6; /* Violet-500 */
            background-color: #EDE9FE; /* Violet-100 */
            box-shadow: 0 10px 20px rgba(0,0,0,0.1), 0 6px 6px rgba(0,0,0,0.1);
        }
        .candy {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem; /* Ø§Ù†Ø¯Ø§Ø²Ù‡ ÙÙˆÙ†Øª ÙˆØ§Ú©Ù†Ø´â€ŒÚ¯Ø±Ø§ */
            cursor: pointer;
            user-select: none;
            /* Ø§Ù†ÛŒÙ…ÛŒØ´Ù† Ø§ØµÙ„ÛŒ Ø¨Ø±Ø§ÛŒ Ø­Ø±Ú©Øª Ùˆ Ø´ÙØ§ÙÛŒØª */
            transition: transform 0.3s ease, opacity 0.3s ease;
            aspect-ratio: 1 / 1;
            will-change: transform; /* Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ù†ÛŒÙ…ÛŒØ´Ù† */
        }
        .candy.selected {
            transform: scale(1.1);
            background-color: rgba(255, 255, 0, 0.5);
            border-radius: 50%;
        }
        .candy.is-match {
            animation: pop 0.5s ease-out forwards;
        }
        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.4); opacity: 0.7; }
            100% { transform: scale(0); opacity: 0; }
        }
        @media (max-width: 640px) {
            .candy {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body class="bg-violet-200 flex flex-col items-center justify-center min-h-screen p-4">

    <div class="bg-white rounded-2xl shadow-2xl p-6 md:p-8 w-full max-w-md text-center">
        <h1 class="text-3xl md:text-4xl font-bold text-violet-700 mb-2">Ú©Ù†Ø¯ÛŒ Ú©Ø±Ø§Ø´</h1>
        <p class="text-gray-600 mb-4">Ø³Ù‡ ÛŒØ§ Ú†Ù†Ø¯ Ø¢Ø¨Ù†Ø¨Ø§Øª Ù‡Ù…Ø±Ù†Ú¯ Ø±Ø§ Ú©Ù†Ø§Ø± Ù‡Ù… Ù‚Ø±Ø§Ø± Ø¯Ù‡ÛŒØ¯ ØªØ§ Ø§Ù…ØªÛŒØ§Ø² Ø¨Ú¯ÛŒØ±ÛŒØ¯!</p>
        
        <div class="flex justify-around items-center bg-violet-100 p-3 rounded-lg mb-6">
            <div>
                <h2 class="text-lg font-bold text-violet-600">Ø§Ù…ØªÛŒØ§Ø²</h2>
                <p id="score" class="text-2xl font-bold text-gray-800">0</p>
            </div>
        </div>

        <div id="game-board" class="grid-container rounded-xl w-full max-w-sm mx-auto">
            </div>

        <div class="mt-6 space-y-3">
             <button id="restart-btn" class="w-full bg-violet-600 hover:bg-violet-700 text-white font-bold py-3 px-4 rounded-lg text-lg transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-violet-300">
                Ø´Ø±ÙˆØ¹ Ù…Ø¬Ø¯Ø¯
            </button>
            <button id="sound-btn" class="w-full bg-pink-500 hover:bg-pink-600 text-white font-bold py-3 px-4 rounded-lg text-lg transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-pink-300 disabled:bg-pink-300 disabled:cursor-not-allowed">
                ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ ØµØ¯Ø§
            </button>
            <button id="close-btn" class="w-full bg-gray-500 hover:bg-gray-600 text-white font-bold py-3 px-4 rounded-lg text-lg transition-transform transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-gray-300">
                Ø®Ø±ÙˆØ¬
            </button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const gameBoard = document.getElementById('game-board');
            const scoreElement = document.getElementById('score');
            const restartBtn = document.getElementById('restart-btn');
            const soundBtn = document.getElementById('sound-btn');
            const closeBtn = document.getElementById('close-btn'); // Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡

            const gridWidth = 8;
            const gridHeight = 8;
            const candies = ['ğŸ¬', 'ğŸ­', 'ğŸ«', 'ğŸ©', 'ğŸª', 'ğŸ§'];
            let board = [];
            let score = 0;
            let selectedCandy = null;
            let isProcessing = false;

            let sounds = {};
            let soundInitialized = false;

            function initializeSounds() {
                if (soundInitialized) return;
                try {
                    sounds = {
                        'ğŸ¬': new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 } }).toDestination(),
                        'ğŸ­': new Tone.PluckSynth().toDestination(),
                        'ğŸ«': new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.005, decay: 0.15, sustain: 0 } }).toDestination(),
                        'ğŸ©': new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.02, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination(),
                        'ğŸª': new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.05, sustain: 0 } }).toDestination(),
                        'ğŸ§': new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 5, envelope: { attack: 0.001, decay: 0.3, sustain: 0.01, release: 0.5 } }).toDestination()
                    };
                    soundInitialized = true;
                } catch (e) {
                    console.error("Error initializing sounds:", e);
                }
            }
            
            function playSoundForCandy(candyEmoji) {
                if (!soundInitialized || !sounds[candyEmoji]) return;
                const sound = sounds[candyEmoji];
                if (sound instanceof Tone.PluckSynth) sound.triggerAttack("C5");
                else if (sound instanceof Tone.NoiseSynth) sound.triggerAttackRelease("8n");
                else sound.triggerAttackRelease("C5", "8n");
            }

            function createBoard() {
                board = [];
                gameBoard.innerHTML = '';
                for (let r = 0; r < gridHeight; r++) {
                    const row = [];
                    for (let c = 0; c < gridWidth; c++) {
                        const candyElement = document.createElement('div');
                        candyElement.classList.add('candy');
                        let randomCandy;
                        do {
                           randomCandy = candies[Math.floor(Math.random() * candies.length)];
                        } while (
                           (c >= 2 && row[c-1].candy === randomCandy && row[c-2].candy === randomCandy) ||
                           (r >= 2 && board[r-1][c].candy === randomCandy && board[r-2][c].candy === randomCandy)
                        );
                        candyElement.textContent = randomCandy;
                        const candyData = { element: candyElement, candy: randomCandy, row: r, col: c };
                        row.push(candyData);
                        gameBoard.appendChild(candyElement);
                    }
                    board.push(row);
                }
                updateBoardVisuals();
                addEventListeners();
            }

            function addEventListeners() {
                gameBoard.addEventListener('click', onCandyClick);
            }

            function onCandyClick(event) {
                if (isProcessing) return;
                const clickedCandyElement = event.target.closest('.candy');
                if (!clickedCandyElement) return;
                const { row, col } = findCandyByElement(clickedCandyElement);
                const clickedCandy = board[row][col];
                if (!selectedCandy) {
                    selectedCandy = clickedCandy;
                    selectedCandy.element.classList.add('selected');
                } else {
                    const isAdjacent = Math.abs(selectedCandy.row - clickedCandy.row) + Math.abs(selectedCandy.col - clickedCandy.col) === 1;
                    selectedCandy.element.classList.remove('selected');
                    if (isAdjacent) {
                        swapAndCheck(selectedCandy, clickedCandy);
                    }
                    selectedCandy = null;
                }
            }
            
            function findCandyByElement(element) {
                for(let r = 0; r < gridHeight; r++) {
                    for (let c = 0; c < gridWidth; c++) {
                        if (board[r][c].element === element) return { row: r, col: c };
                    }
                }
                return null;
            }

            async function swapAndCheck(candy1, candy2) {
                isProcessing = true;
                await swapCandies(candy1, candy2);
                const matchFound = await checkAndProcessMatches();
                if (!matchFound) {
                    await new Promise(resolve => setTimeout(resolve, 300));
                    await swapCandies(candy1, candy2);
                }
                isProcessing = false;
            }

            async function swapCandies(candy1, candy2) {
                board[candy1.row][candy1.col] = candy2;
                board[candy2.row][candy2.col] = candy1;
                [candy1.row, candy2.row] = [candy2.row, candy1.row];
                [candy1.col, candy2.col] = [candy2.col, candy1.col];
                updateBoardVisuals();
                return new Promise(resolve => setTimeout(resolve, 300));
            }

            async function checkAndProcessMatches() {
                let anyMatchFound = false;
                let keepChecking = true;

                while(keepChecking) {
                    const matches = findMatches();
                    if (matches.size > 0) {
                        // Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø§ÛŒØ¬Ø§Ø¯ ÙˆÛŒØ¨Ø±Ù‡ Ù‡Ù†Ú¯Ø§Ù… Ù¾ÛŒØ¯Ø§ Ø´Ø¯Ù† ØªØ·Ø§Ø¨Ù‚
                        if (window.Telegram && window.Telegram.WebApp) {
                            window.Telegram.WebApp.HapticFeedback.impactOccurred('light');
                        }

                        anyMatchFound = true;
                        score += matches.size * 10;
                        updateScore();

                        const firstMatchedCandy = matches.values().next().value;
                        playSoundForCandy(firstMatchedCandy.candy);

                        matches.forEach(candy => candy.element.classList.add('is-match'));
                        await new Promise(resolve => setTimeout(resolve, 500)); 

                        matches.forEach(candy => { board[candy.row][candy.col].candy = null; });
                        
                        updateBoardVisuals();
                        await new Promise(resolve => setTimeout(resolve, 100));

                        await dropCandies();
                        await fillBoard();
                    } else {
                        keepChecking = false;
                    }
                }
                return anyMatchFound;
            }

            function findMatches() {
                const matchedCandies = new Set();
                for (let r = 0; r < gridHeight; r++) {
                    for (let c = 0; c < gridWidth - 2; c++) {
                        let c1 = board[r][c], c2 = board[r][c+1], c3 = board[r][c+2];
                        if (c1.candy && c1.candy === c2.candy && c2.candy === c3.candy) {
                            [c1, c2, c3].forEach(c => matchedCandies.add(c));
                        }
                    }
                }
                for (let c = 0; c < gridWidth; c++) {
                    for (let r = 0; r < gridHeight - 2; r++) {
                        let c1 = board[r][c], c2 = board[r+1][c], c3 = board[r+2][c];
                        if (c1.candy && c1.candy === c2.candy && c2.candy === c3.candy) {
                            [c1, c2, c3].forEach(c => matchedCandies.add(c));
                        }
                    }
                }
                return matchedCandies;
            }

            async function dropCandies() {
                for (let c = 0; c < gridWidth; c++) {
                    let emptyRow = gridHeight - 1;
                    for (let r = gridHeight - 1; r >= 0; r--) {
                        if (board[r][c].candy !== null) {
                            if (r !== emptyRow) {
                                board[emptyRow][c].candy = board[r][c].candy;
                                board[r][c].candy = null;
                            }
                            emptyRow--;
                        }
                    }
                }
                updateBoardVisuals();
                return new Promise(resolve => setTimeout(resolve, 300));
            }

            async function fillBoard() {
                for (let r = 0; r < gridHeight; r++) {
                    for (let c = 0; c < gridWidth; c++) {
                        if (board[r][c].candy === null) {
                           board[r][c].candy = candies[Math.floor(Math.random() * candies.length)];
                           board[r][c].element.style.transition = 'none';
                           board[r][c].element.style.transform = `translateY(-200%)`;
                           board[r][c].element.classList.remove('is-match');
                        }
                    }
                }
                updateBoardVisuals();
                await new Promise(resolve => setTimeout(resolve, 20));
                for (let r = 0; r < gridHeight; r++) {
                    for (let c = 0; c < gridWidth; c++) {
                        board[r][c].element.style.transition = 'transform 0.3s ease';
                        board[r][c].element.style.transform = '';
                    }
                }
                return new Promise(resolve => setTimeout(resolve, 300));
            }
            
            function updateBoardVisuals() {
                for(let r=0;r<gridHeight;r++)for(let c=0;c<gridWidth;c++){const a=board[r][c],b=a.element;b.style.gridRowStart=r+1,b.style.gridColumnStart=c+1,null===a.candy?(b.textContent="",b.style.opacity="0"):(b.textContent=a.candy,b.style.opacity="1"),b.classList.remove("is-match")}
            }
            function updateScore() { scoreElement.textContent = score; }
            function restartGame() {
                isProcessing=false;score=0;updateScore();selectedCandy=null;createBoard();
            }

            // --- Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ Ø¯Ú©Ù…Ù‡ Ù‡Ø§ ---
            restartBtn.addEventListener('click', restartGame);
            
            // Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø±ÙˆÛŒØ¯Ø§Ø¯ Ø¯Ú©Ù…Ù‡ Ø®Ø±ÙˆØ¬
            closeBtn.addEventListener('click', () => {
                if (window.Telegram && window.Telegram.WebApp) {
                    window.Telegram.WebApp.close();
                }
            });

            soundBtn.addEventListener('click', async () => {
                try {
                    await Tone.start();
                    initializeSounds();
                    soundBtn.textContent = 'ØµØ¯Ø§ ÙØ¹Ø§Ù„ Ø§Ø³Øª';
                    soundBtn.disabled = true;
                } catch (e) {
                    console.error("Could not start audio context: ", e);
                }
            });

            // --- Ø´Ø±ÙˆØ¹ Ø§ÙˆÙ„ÛŒÙ‡ ---
            createBoard();
            
            // Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯Ù‡: Ø¨Ù‡ ØªÙ„Ú¯Ø±Ø§Ù… Ø§Ø·Ù„Ø§Ø¹ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ Ú©Ù‡ ÙˆØ¨ Ø§Ù¾ Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø³Øª
            if (window.Telegram && window.Telegram.WebApp) {
                window.Telegram.WebApp.ready();
            }
        });
    </script>
</body>
</html>
